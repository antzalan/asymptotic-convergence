function [W, agreement] = precoder_CDZF(He_M, Mn, q, mu, quant_channel, P, pow_control, quant_pw_reduct_ch)
% precoder_CDZF: 
% Function that computes the proposed CD-ZF precoding matrix. 
%
% In this algorithm, there is a set of "dumb" TXs, for which the precoding vectors
% are applied after a quantization of values in order to allow the TXs with more
% accurate CSIT to compensate and correct the interference generated by the CSIT
% noise. 
% In this algorithm, the relation between consistency and precision is crucial.
%
% INPUTS:  He_M: Channel matrix estimates at each TX
%            Mn: Num. antennas at each TX
%             q: Quantization step. Value of the granularity of the quantization. 
%            mu: back-off power factor. 0 < mu <= 1, allows to adapt to possible power
%                outages in case of instantaneous power constraints. (see paper)
% quant_channel: Boolean: Either channel quantization or precoder quantization. 
%                 quant_channel == 1 => the quantization is done at the input (channel matrix)
%                 quant_channel == 0 => the quantization is done at the output (precoder vector)
%                (It is Better to choose precoder quantization, better performance, 
%                 reduced dimensionality. see paper)
%             P: Power (or SNR) or the setting 
%   pow_control: Different power normalizations available. 
%                Choices are:
%
%                   - 'per_Antenna': Instantaneous power norm. per antenna 
%                   - 'per_TX': Instantaneous power norm. per TX 
%                   - 'average_perTX': Average power norm. per antenna      
%                   - 'average_perAntenna': Average power norm. per TX 
%
%  quant_pw_reduct_ch: Since the quantization applied is quantizing the closest 
%               value towards 0, the quantization applied to the channel matrix reduces 
%               the mean power of the coefficients proportionally to the following expression:
%                       quant_pw_reduct_ch = 1-cdf('Exponential', q, 1); 
%
% OUTPUT: Vector of size Num.TX-antennas x Num.RXs 
%

    K    = size(He_M, 1);  % Number of RXs
    Mt   = size(He_M, 2);  % Total number of transmit antennas
    M    = size(He_M, 3);  % Number of TXs
    
    W = zeros(Mt,K);       % Initializing Precoding matrix 
      
    %% Precoder at dumb TXs
    n_ant_prev = Mn(1);

    for m = 2:M  % At TX m
        He_m = He_M(:,:,m); % Global channel Estimate at TX m

        if quant_channel  % If quantization is done at input (channel matrix)
            He_m_q = alpha_quantizer(He_m, q, quant_channel); % quantize matrix
            He_m_q = He_m_q/quant_pw_reduct_ch; % Correction to have a channel mtrix with unit mean
        else % If quantization is done at output (precoding matrix)
            He_m_q = He_m; %nothing
        end
        
        %%% Dumb TXs compute the naive precoder (centralized precoder assuming that
        %%% the other TXs share the same CSIT).
        W_m = precoder_CENTRALIZED(He_m_q, Mn, P, pow_control); % Naive centralized precoder
       
        %%% Building effective precoder at dumb TXs
        vec_ant_TX_m = n_ant_prev + 1 : n_ant_prev + Mn(m); % current TX's antennas
        n_ant_prev = n_ant_prev + Mn(m);  % Updating index of antennas
           
        if quant_channel  % If quantization is done at input (channel matrix)  
            W_TX_m_q = W_m(vec_ant_TX_m,:); %nothing
        else % If quantization is done at output (precoding matrix)
            W_TX_m_q = alpha_quantizer(W_m(vec_ant_TX_m,:), q, quant_channel); % quantize matrix
            W_TX_m_q = W_TX_m_q/quant_pw_reduct_ch; % Correction to have a precoder with same average power as before quantization
        end

        W(vec_ant_TX_m,:) = mu*W_TX_m_q; % Coef. used by TX m
    end

    %% Precoder at smart TXs (now only TX 1)
    He  = squeeze(He_M(:,:,1)); % Global channel estimate at TX 1
    V_1 = precoder_CENTRALIZED(He, Mn, P, pow_control); % Centralized precoder if everyone shared TX 1's estimate
        
    if quant_channel  % If quantization is done at input (channel matrix)  
        He_q = alpha_quantizer(He, q, quant_channel); % quantizing channel matrix        
        He_q = He_q/quant_pw_reduct_ch; % Correction to have a channel matrix with unit mean
        W_TX_m_atTX1 = precoder_CENTRALIZED(He_q, Mn, P, pow_control); % Centralized precoder if everyone shared TX 1's estimate
        W_TXs_atTX1  = mu*W_TX_m_atTX1(Mn(1)+1:end, :);
    else % Estimate at TX 1 of the precoders at other TXs;
        W_m_TX1 = V_1; % Naive centralized precoder
        %%% Building effective precoder       
        W_TX_m_atTX1_q = alpha_quantizer(W_m_TX1, q, quant_channel); % quantizing precoding matrix
        W_TX_m_atTX1_q = W_TX_m_atTX1_q/quant_pw_reduct_ch; % Correction to have a precoder with same average power as before quantization
  
        W_TXs_atTX1    = mu*W_TX_m_atTX1_q(Mn(1)+1:end, :); % Coef. used by TX m                  
    end    
    
    agreement = (W(Mn(1)+1:end, :) == W_TXs_atTX1); % Just for verifying if the values match

    %% TX 1 corrects interference from other TXs 
    W1_preNorm  = zeros(Mn(1), K); % Init precoder at TX 1  
    v_ant_noTX1 = Mn(1)+1:Mt;     % index of antnna for TXs 2 ... M
    v_ant_TX1   = 1:Mn(1);        % Index of antennas for TX 1

    for i = 1:K   % For each user            
        H_i_bar         = He([1:i-1,i+1:end], :);  % Channel matrix for all the RXs except RX i
        h_i_bar_TX1     = H_i_bar(:, v_ant_TX1);   % Coefs of TXs except TX 1
        h_i_bar_not_TX1 = H_i_bar(:, v_ant_noTX1); % Coefs of TX 1

        h_inv = h_i_bar_TX1'/(h_i_bar_TX1*h_i_bar_TX1'+ 1/sqrt(K*P)*eye(K-1))*h_i_bar_not_TX1; % Precoder correction at TX 1 with regularization
                 
        v_i     = V_1(:,i); % Centralized precoder for RX i
        diff_vw = mu*v_i(v_ant_noTX1) - W_TXs_atTX1(:,i); % Diff between naive decentralized and centalized ideal precoder 

        W1_preNorm(:,i) = mu*v_i(v_ant_TX1) + h_inv*diff_vw;    % Precoder at TX 1      
    end  

%% Precoder normalization per TX  
    if strcmp(pow_control, 'per_Antenna')
        norm_perAntenna = sqrt(sum(abs(W1_preNorm).^2,2));
        normalization   = max([norm_perAntenna;1]);
        W1 = W1_preNorm/normalization;     
        
    elseif strcmp(pow_control, 'per_TX')
        norm_perTX = norm(W1_preNorm);
        W1  = W1_preNorm/max([norm_perTX; 1]);  

    elseif strcmp(pow_control, 'average_perTX')
        W1 = W1_preNorm;
        
    elseif strcmp(pow_control, 'average_perAntenna')
        W1 = W1_preNorm;
        
    else 
        error('Unknown power control')
    end
    
    %%% Updating final effective precoder
    W(1:Mn(1),:) = W1;           

end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author: Antonio Bazco-Nogueras  
% Date: 2022/05/11
% Contact: antonio.bazco@imdea.org
% License: This file can be distributed, remixed, adapted, and other work can be
% built upon it, as long as appropiate credit is included for the original creation. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%